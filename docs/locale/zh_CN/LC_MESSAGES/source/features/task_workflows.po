# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2024, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 1.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-05 10:49+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Ziqi Fan <fanziqi614@gmail.com>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.15.0\n"

#: ../../source/features/task_workflows.rst:5
msgid "Task Design Workflows"
msgstr "任务设计工作流"

#: ../../source/features/task_workflows.rst:9
msgid ""
"Environments define the interface between the agent and the simulation. In "
"the simplest case, the environment provides the agent with the current "
"observations and executes the actions provided by the agent. In a Markov "
"Decision Process (MDP) formulation, the environment can also provide "
"additional information such as the current reward, done flag, and "
"information about the current episode."
msgstr ""
"环境定义了代理和模拟之间的接口。在最简单的情况下，环境提供代理当前的观察结果并执行代理提供的操作。在马尔可夫决策过程（MDP）的形式化中，环境还可以提供额外的信息，如当前奖励、完成标志和当前情节的信息。"

#: ../../source/features/task_workflows.rst:14
msgid ""
"While the environment interface is simple to understand, its implementation "
"can vary significantly depending on the complexity of the task. In the "
"context of reinforcement learning (RL), the environment implementation can "
"be broken down into several components, such as the reward function, "
"observation function, termination function, and reset function. Each of "
"these components can be implemented in different ways depending on the "
"complexity of the task and the desired level of modularity."
msgstr ""
"虽然环境接口很容易理解，但根据任务的复杂性，其实现可能会有很大差异。在强化学习（RL）的背景下，环境的实现可以分解为几个组件，如奖励函数、观察函数、终止函数和重置函数。根据任务的复杂性和所需的模块化级别，每个组件可以以不同的方式实现。"

#: ../../source/features/task_workflows.rst:20
msgid ""
"We provide two different workflows for designing environments with the "
"framework:"
msgstr "我们为设计框架提供了两种不同的工作流："

#: ../../source/features/task_workflows.rst:22
msgid ""
"**Manager-based**: The environment is decomposed into individual components "
"(or managers) that handle different aspects of the environment (such as "
"computing observations, applying actions, and applying randomization). The "
"user defines configuration classes for each component and the environment is"
" responsible for coordinating the managers and calling their functions."
msgstr ""
"基于管理器：环境被分解为处理环境不同方面的单个组件（或管理器）（如计算观察、应用操作和应用随机化）。用户为每个组件定义配置类，环境负责协调管理器并调用它们的函数。"

#: ../../source/features/task_workflows.rst:26
msgid ""
"**Direct**: The user defines a single class that implements the entire "
"environment directly without the need for separate managers. This class is "
"responsible for computing observations, applying actions, and computing "
"rewards."
msgstr "直接：用户定义一个实现整个环境的单个类，而无需单独的管理器。该类负责计算观察、应用操作和计算奖励。"

#: ../../source/features/task_workflows.rst:29
msgid ""
"Both workflows have their own advantages and disadvantages. The manager-"
"based workflow is more modular and allows different components of the "
"environment to be swapped out easily. This is useful when prototyping the "
"environment and experimenting with different configurations. On the other "
"hand, the direct workflow is more efficient and allows for more fine-grained"
" control over the environment logic. This is useful when optimizing the "
"environment for performance or when implementing complex logic that is "
"difficult to decompose into separate components."
msgstr ""
"这两种工作流各有优缺点。基于管理器的工作流更具模块化，可以轻松地切换环境的不同组件。在原型环境和试验不同配置时很有用。另一方面，直接的工作流更高效，提供了更精细的控制环境逻辑的能力。在优化环境性能或实施难以分解为单独组件的复杂逻辑时很有用。"

#: ../../source/features/task_workflows.rst:37
msgid "Manager-Based Environments"
msgstr "基于管理器的环境"

#: ../../source/features/task_workflows.rst:39
msgid ""
"A majority of environment implementations follow a similar structure. The "
"environment processes the input actions, steps through the simulation, "
"computes observations and reward signals, applies randomization, and resets "
"the terminated environments. Motivated by this, the environment can be "
"decomposed into individual components that handle each of these tasks. For "
"example, the observation manager is responsible for computing the "
"observations, the reward manager is responsible for computing the rewards, "
"and the termination manager is responsible for computing the termination "
"signal. This approach is known as the manager-based environment design in "
"the framework."
msgstr ""
"大多数环境实现都遵循相似的结构。环境处理输入操作，模拟步骤，计算观察和奖励，应用随机化，并重置终止的环境。受此激励，环境可以被分解为处理每一个任务的单个组件。例如，观察管理器负责计算观察，奖励管理器负责计算奖励，终止管理器负责计算终止信号。该方法称为框架中的基于管理器的环境设计。"

#: ../../source/features/task_workflows.rst:46
msgid ""
"Manager-based environments promote modular implementations of tasks by "
"decomposing the task into individual components that are managed by separate"
" classes. Each component of the task, such as rewards, observations, "
"termination can all be specified as individual configuration classes that "
"are then passed to the corresponding manager classes. The manager is then "
"responsible for parsing the configurations and processing the contents "
"specified in its configuration."
msgstr ""
"基于管理器的环境通过将任务分解为由单独类管理的单个组件，促进了任务的模块化实现。任务的每个组件，如奖励、观察、终止都可以作为单独的配置类指定，然后传递给相应的管理器类。然后管理器负责解析配置并处理其配置中指定的内容。"

#: ../../source/features/task_workflows.rst:52
msgid ""
"The coordination between the different managers is orchestrated by the class"
" :class:`envs.ManagerBasedRLEnv`. It takes in a task configuration class "
"instance (:class:`envs.ManagerBasedRLEnvCfg`) that contains the "
"configurations for each of the components of the task. Based on the "
"configurations, the scene is set up and the task is initialized. Afterwards,"
" while stepping through the environment, all the managers are called "
"sequentially to perform the necessary operations."
msgstr ""
"不同管理器的协作由类 :class:`envs.ManagerBasedRLEnv` 进行编排。它接受任务配置类的实例（ "
":class:`envs.ManagerBasedRLEnvCfg` "
"），其中包含任务各组件的配置。根据配置，设置场景并初始化任务。之后，通过环境，按顺序调用所有管理器执行必要的操作。"

#: ../../source/features/task_workflows.rst:58
msgid ""
"For their own tasks, we expect the user to mainly define the task "
"configuration class and use the existing :class:`envs.ManagerBasedRLEnv` "
"class for the task implementation. The task configuration class should "
"inherit from the base class :class:`envs.ManagerBasedRLEnvCfg` and contain "
"variables assigned to various configuration classes for each component (such"
" as the ``ObservationCfg`` and ``RewardCfg``)."
msgstr ""
"对于他们自己的任务，我们期望用户主要定义任务配置类，并使用现有的 :class:`envs.ManagerBasedRLEnv` "
"类进行任务实现。任务配置类应继承自基类 :class:`envs.ManagerBasedRLEnvCfg` "
"，并包含分配给不同组件的各个配置类的变量（如 ``ObservationCfg`` 和 ``RewardCfg`` ）。"

#: ../../source/features/task_workflows.rst
msgid ""
"Example for defining the reward function for the Cartpole task using the "
"manager-style"
msgstr "使用管理器样式为Cartpole任务定义奖励函数的示例"

#: ../../source/features/task_workflows.rst:66
msgid ""
"The following class is a part of the Cartpole environment configuration "
"class. The :class:`RewardsCfg` class defines individual terms that compose "
"the reward function. Each reward term is defined by its function "
"implementation, weight and additional parameters to be passed to the "
"function. Users can define multiple reward terms and their weights to be "
"used in the reward function."
msgstr ""
"以下类是Cartpole环境配置类的一部分。 :class:`RewardsCfg` "
"类定义了组成奖励函数的单个项。每个奖励项由其函数实现、权重和传递给函数的其他参数来定义。用户可以定义多个奖励项和它们的权重以在奖励函数中使用。"

#: ../../source/features/task_workflows.rst:76
msgid ""
"Through this approach, it is possible to easily vary the implementations of "
"the task by switching some components while leaving the remaining of the "
"code intact. This flexibility is desirable when prototyping the environment "
"and experimenting with different configurations. It also allows for easy "
"collaborating with others on implementing an environment, since contributors"
" may choose to use different combinations of configurations for their own "
"task specifications."
msgstr ""
"通过这种方法，可以轻松地通过切换一些组件来改变任务的实现方式，同时保持代码的其余部分不变。在原型环境和试验不同配置时，此灵活性非常有用。它还允许与他人轻松合作实施环境，因为贡献者可以选择使用不同的配置组合来规定自己的任务规格。"

#: ../../source/features/task_workflows.rst:84
msgid ""
"We provide a more detailed tutorial for setting up an environment using the "
"manager-based workflow at :ref:`tutorial-create-manager-rl-env`."
msgstr "我们为使用基于管理器的工作流设置环境提供了更详细的教程： :ref:`tutorial-create-manager-rl-env` 。"

#: ../../source/features/task_workflows.rst:89
msgid "Direct Environments"
msgstr "直接环境"

#: ../../source/features/task_workflows.rst:91
msgid ""
"The direct-style environment aligns more closely with traditional "
"implementations of environments, where a single script directly implements "
"the reward function, observation function, resets, and all the other "
"components of the environment. This approach does not require the manager "
"classes. Instead, users are provided the complete freedom to implement their"
" task through the APIs from the base class :class:`envs.DirectRLEnv`. For "
"users migrating from the `IsaacGymEnvs`_ and `OmniIsaacGymEnvs`_ framework, "
"this workflow may be more familiar."
msgstr ""
"直接样式的环境与传统的环境实现更加接近，其中一个单独的脚本直接实现奖励函数、观察函数、重置和环境的所有其他组件。这种方法不需要管理器类。相反，用户可以通过基类"
" :class:`envs.DirectRLEnv` 的API完全自由地实现他们的任务。对于从 `IsaacGymEnvs`_ 和 "
"`OmniIsaacGymEnvs`_ 框架迁移的用户，这种工作流可能更为熟悉。"

#: ../../source/features/task_workflows.rst:97
msgid ""
"When defining an environment with the direct-style implementation, we expect"
" the user define a single class that implements the entire environment. The "
"task class should inherit from the base :class:`envs.DirectRLEnv` class and "
"should have its corresponding configuration class that inherits from "
":class:`envs.DirectRLEnvCfg`. The task class is responsible for setting up "
"the scene, processing the actions, computing the rewards, observations, "
"resets, and termination signals."
msgstr ""
"在使用直接样式实现的环境时，我们期望用户定义一个实现整个环境的单个类。任务类应继承自基类 :class:`envs.DirectRLEnv` "
"，应该有相应的配置类，继承自 :class:`envs.DirectRLEnvCfg` 。任务类负责设置场景，处理操作，计算奖励、观察、重置、终止信号。"

#: ../../source/features/task_workflows.rst
msgid ""
"Example for defining the reward function for the Cartpole task using the "
"direct-style"
msgstr "使用直接样式为Cartpole任务定义奖励函数的示例"

#: ../../source/features/task_workflows.rst:105
msgid ""
"The following function is a part of the Cartpole environment class and is "
"responsible for computing the rewards."
msgstr "以下函数是Cartpole环境类的一部分，负责计算奖励。"

#: ../../source/features/task_workflows.rst:112
msgid ""
"It calls the :meth:`compute_rewards` function which is Torch JIT compiled "
"for performance benefits."
msgstr "它调用了 :meth:`compute_rewards` 函数，该函数是为了性能优势而Torch JIT编译的"

#: ../../source/features/task_workflows.rst:118
msgid ""
"This approach provides more transparency in the implementations of the "
"environments, as logic is defined within the task class instead of "
"abstracted with the use of managers. This may be beneficial when "
"implementing complex logic that is difficult to decompose into separate "
"components. Additionally, the direct-style implementation may bring more "
"performance benefits for the environment, as it allows implementing large "
"chunks of logic with optimized frameworks such as `PyTorch JIT`_ or `Warp`_."
" This may be valuable when scaling up training tremendously which requires "
"optimizing individual operations in the environment."
msgstr ""
"这种方法在环境实现中提供了更多的透明度，因为逻辑是在任务类中而不是通过使用管理器进行抽象来定义的。在实现难以分解为单独组件的复杂逻辑时，这可能是有益的。此外，直接样式的实现可能为环境带来更好的性能优势，因为它允许使用优化的框架（如"
" `PyTorch JIT`_ 和 `Warp`_ ）实现大量逻辑。这在需要优化环境中的每个操作时可能非常有价值。"

#: ../../source/features/task_workflows.rst:127
msgid ""
"We provide a more detailed tutorial for setting up a RL environment using "
"the direct workflow at :ref:`tutorial-create-direct-rl-env`."
msgstr "我们为使用直接工作流设置RL环境提供了更详细的教程： :ref:`tutorial-create-direct-rl-env` 。"
