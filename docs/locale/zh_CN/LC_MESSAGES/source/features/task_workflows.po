# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2024, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 1.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-04 11:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.15.0\n"

#: ../../source/features/task_workflows.rst:5
msgid "Task Design Workflows"
msgstr "任务设计工作流"

#: ../../source/features/task_workflows.rst:9
msgid ""
"Environments define the interface between the agent and the simulation. In "
"the simplest case, the environment provides the agent with the current "
"observations and executes the actions provided by the agent. In a Markov "
"Decision Process (MDP) formulation, the environment can also provide "
"additional information such as the current reward, done flag, and "
"information about the current episode."
msgstr ""
"环境定义代理和模拟之间的接口。在最简单的情况下，环境为代理提供当前观察结果并执行代理提供的操作。在马尔可夫决策过程（MDP）的制定中，环境还可以提供额外的信息，如当前奖励、完成标志和有关当前情节的信息。"

#: ../../source/features/task_workflows.rst:14
msgid ""
"While the environment interface is simple to understand, its implementation "
"can vary significantly depending on the complexity of the task. In the "
"context of reinforcement learning (RL), the environment implementation can "
"be broken down into several components, such as the reward function, "
"observation function, termination function, and reset function. Each of "
"these components can be implemented in different ways depending on the "
"complexity of the task and the desired level of modularity."
msgstr ""
"虽然环境接口的理解很简单，但其实现因任务复杂程度的不同而显著变化。在强化学习（RL）的情境下，环境实现可以分解为多个部分，如奖励函数、观察函数、终止函数和重置函数。这些组件中的每一个可以根据任务的复杂程度和所需的模块化水平以不同的方式实现。"

#: ../../source/features/task_workflows.rst:20
msgid ""
"We provide two different workflows for designing environments with the "
"framework:"
msgstr "我们为使用该框架设计环境提供了两种不同的工作流程："

#: ../../source/features/task_workflows.rst:22
msgid ""
"**Manager-based**: The environment is decomposed into individual components "
"(or managers) that handle different aspects of the environment (such as "
"computing observations, applying actions, and applying randomization). The "
"user defines configuration classes for each component and the environment is"
" responsible for coordinating the managers and calling their functions."
msgstr ""
"**基于管理器**: "
"环境被分解为处理环境不同方面的单个组件（或管理器）（如计算观察结果、应用操作和应用随机化）。用户为每个组件定义配置类，环境负责协调管理器并调用其函数。"

#: ../../source/features/task_workflows.rst:26
msgid ""
"**Direct**: The user defines a single class that implements the entire "
"environment directly without the need for separate managers. This class is "
"responsible for computing observations, applying actions, and computing "
"rewards."
msgstr "**直接**: 用户定义一个实现整个环境而无需单独管理器的单个类。这个类负责计算观察结果，应用操作并计算奖励。"

#: ../../source/features/task_workflows.rst:29
msgid ""
"Both workflows have their own advantages and disadvantages. The manager-"
"based workflow is more modular and allows different components of the "
"environment to be swapped out easily. This is useful when prototyping the "
"environment and experimenting with different configurations. On the other "
"hand, the direct workflow is more efficient and allows for more fine-grained"
" control over the environment logic. This is useful when optimizing the "
"environment for performance or when implementing complex logic that is "
"difficult to decompose into separate components."
msgstr ""
"这两种工作流都各有优缺点。基于管理器的工作流更模块化，可以轻松地更换环境的不同组件。这在原型环境并尝试不同配置时非常有用。另一方面，直接工作流更高效，并允许更精细地控制环境逻辑。这在优化环境性能或实现难以分解为单独组件的复杂逻辑时非常有用。"

#: ../../source/features/task_workflows.rst:37
msgid "Manager-Based Environments"
msgstr "基于管理器的环境"

#: ../../source/features/task_workflows.rst:39
msgid ""
"A majority of environment implementations follow a similar structure. The "
"environment processes the input actions, steps through the simulation, "
"computes observations and reward signals, applies randomization, and resets "
"the terminated environments. Motivated by this, the environment can be "
"decomposed into individual components that handle each of these tasks. For "
"example, the observation manager is responsible for computing the "
"observations, the reward manager is responsible for computing the rewards, "
"and the termination manager is responsible for computing the termination "
"signal. This approach is known as the manager-based environment design in "
"the framework."
msgstr ""
"大多数环境实现都遵循类似的结构。环境处理输入操作，通过模拟进行步骤，计算观察结果和奖励信号，应用随机化并重置终止的环境。因此，环境可以分解为处理这些任务的各个组件。例如，观察管理器负责计算观察结果，奖励管理器负责计算奖励，终止管理器负责计算终止信号。这种方式被称为框架中的基于管理器的环境设计。"

#: ../../source/features/task_workflows.rst:46
msgid ""
"Manager-based environments promote modular implementations of tasks by "
"decomposing the task into individual components that are managed by separate"
" classes. Each component of the task, such as rewards, observations, "
"termination can all be specified as individual configuration classes that "
"are then passed to the corresponding manager classes. The manager is then "
"responsible for parsing the configurations and processing the contents "
"specified in its configuration."
msgstr ""
"基于管理器的环境通过将任务分解为单独组件，促进了任务的模块化实现。任务的每个组件，如奖励、观察、终止都可以作为独立配置类指定，并传递给相应的管理器类。管理器然后负责对配置进行解析并处理其中指定的内容。"

#: ../../source/features/task_workflows.rst:52
msgid ""
"The coordination between the different managers is orchestrated by the class"
" :class:`envs.ManagerBasedRLEnv`. It takes in a task configuration class "
"instance (:class:`envs.ManagerBasedRLEnvCfg`) that contains the "
"configurations for each of the components of the task. Based on the "
"configurations, the scene is set up and the task is initialized. Afterwards,"
" while stepping through the environment, all the managers are called "
"sequentially to perform the necessary operations."
msgstr ""
"不同管理器之间的协调由类:class:`envs.ManagerBasedRLEnv`进行编排。它接受一个任务配置类实例(:class:`envs.ManagerBasedRLEnvCfg`)，其中包含任务各组件的配置。根据这些配置，设置场景并初始化任务。然后，在环境中执行操作时，顺序调用所有管理器来执行必要的操作。"

#: ../../source/features/task_workflows.rst:58
msgid ""
"For their own tasks, we expect the user to mainly define the task "
"configuration class and use the existing :class:`envs.ManagerBasedRLEnv` "
"class for the task implementation. The task configuration class should "
"inherit from the base class :class:`envs.ManagerBasedRLEnvCfg` and contain "
"variables assigned to various configuration classes for each component (such"
" as the ``ObservationCfg`` and ``RewardCfg``)."
msgstr ""
"对于他们自己的任务，我们期望用户主要定义任务配置类，并使用现有的:class:`envs.ManagerBasedRLEnv`类执行任务。任务配置类应该继承自基类:class:`envs.ManagerBasedRLEnvCfg`，包含变量分配到各个配置类(如``ObservationCfg``和``RewardCfg``)。"

#: ../../source/features/task_workflows.rst
msgid ""
"Example for defining the reward function for the Cartpole task using the "
"manager-style"
msgstr "使用管理类型定义Cartpole任务奖励功能的示例"

#: ../../source/features/task_workflows.rst:66
msgid ""
"The following class is a part of the Cartpole environment configuration "
"class. The :class:`RewardsCfg` class defines individual terms that compose "
"the reward function. Each reward term is defined by its function "
"implementation, weight and additional parameters to be passed to the "
"function. Users can define multiple reward terms and their weights to be "
"used in the reward function."
msgstr "以下类是Cartpole环境配置类的一部分。"

#: ../../source/features/task_workflows.rst:76
msgid ""
"Through this approach, it is possible to easily vary the implementations of "
"the task by switching some components while leaving the remaining of the "
"code intact. This flexibility is desirable when prototyping the environment "
"and experimenting with different configurations. It also allows for easy "
"collaborating with others on implementing an environment, since contributors"
" may choose to use different combinations of configurations for their own "
"task specifications."
msgstr ""
"通过这种方式，可以通过切换一些组件而保持代码的完整性。这种灵活性在原型环境和尝试不同配置时非常有用。它还允许很容易地协作实现环境，因为贡献者可以选择使用不同的配置组合来为自己的任务规范使用"

#: ../../source/features/task_workflows.rst:84
msgid ""
"We provide a more detailed tutorial for setting up an environment using the "
"manager-based workflow at :ref:`tutorial-create-manager-rl-env`."
msgstr ""
"We provide a more detailed tutorial for setting up an environment using the "
"manager-based workflow at :ref:`tutorial-create-manager-rl-env`."

#: ../../source/features/task_workflows.rst:89
msgid "Direct Environments"
msgstr "直接环境"

#: ../../source/features/task_workflows.rst:91
msgid ""
"The direct-style environment aligns more closely with traditional "
"implementations of environments, where a single script directly implements "
"the reward function, observation function, resets, and all the other "
"components of the environment. This approach does not require the manager "
"classes. Instead, users are provided the complete freedom to implement their"
" task through the APIs from the base class :class:`envs.DirectRLEnv`. For "
"users migrating from the `IsaacGymEnvs`_ and `OmniIsaacGymEnvs`_ framework, "
"this workflow may be more familiar."
msgstr ""
"与环境的传统实现更贴近，直接样式环境是单个脚本直接实现奖励函数、观察函数、重置和环境的所有其他组件。这种方法不需要管理器类。用户可以完全自由地通过基类:class:"
" ‘envs.DirectRLEnv’提供的API实现任务。对于从`IsaacGymEnvs`_ "
"和`OmniIsaacGymEnvs`_框架迁移的用户来说，这个工作流可能更加熟悉"

#: ../../source/features/task_workflows.rst:97
msgid ""
"When defining an environment with the direct-style implementation, we expect"
" the user define a single class that implements the entire environment. The "
"task class should inherit from the base :class:`envs.DirectRLEnv` class and "
"should have its corresponding configuration class that inherits from "
":class:`envs.DirectRLEnvCfg`. The task class is responsible for setting up "
"the scene, processing the actions, computing the rewards, observations, "
"resets, and termination signals."
msgstr ""
"在使用直接样式实现定义环境时，我们希望用户定义一个实现整个环境的单个类。任务类应该从基类:class:`envs.DirectRLEnv`派生，并且应该有相应的配置类，该类从:class:`envs.DirectRLEnvCfg`派生。任务类负责设置场景、处理操作、计算奖励、观察、重置和终止信号。"

#: ../../source/features/task_workflows.rst
msgid ""
"Example for defining the reward function for the Cartpole task using the "
"direct-style"
msgstr "使用直接样式定义Cartpole任务的奖励功能的示例"

#: ../../source/features/task_workflows.rst:105
msgid ""
"The following function is a part of the Cartpole environment class and is "
"responsible for computing the rewards."
msgstr "下面的函数是Cartpole环境类的一部分，并负责计算奖励。"

#: ../../source/features/task_workflows.rst:112
msgid ""
"It calls the :meth:`compute_rewards` function which is Torch JIT compiled "
"for performance benefits."
msgstr "调用:meth:`compute_rewards`函数可以获得性能收益。"

#: ../../source/features/task_workflows.rst:118
msgid ""
"This approach provides more transparency in the implementations of the "
"environments, as logic is defined within the task class instead of "
"abstracted with the use of managers. This may be beneficial when "
"implementing complex logic that is difficult to decompose into separate "
"components. Additionally, the direct-style implementation may bring more "
"performance benefits for the environment, as it allows implementing large "
"chunks of logic with optimized frameworks such as `PyTorch JIT`_ or `Warp`_."
" This may be valuable when scaling up training tremendously which requires "
"optimizing individual operations in the environment."
msgstr ""
"这种方法提供了更多透明性的环境实现，因为逻辑在任务类中定义，而不是使用管理器进行抽象。当实现难以分解的复杂逻辑时，这可能是有益的。此外，直接样式的实现可能会为环境带来更多的性能收益，因为它允许使用优化框架（如PyTorch"
" JIT_或Warp_）来实现大块逻辑。这在需要优化环境中的个别操作时尤为珍贵"

#: ../../source/features/task_workflows.rst:127
msgid ""
"We provide a more detailed tutorial for setting up a RL environment using "
"the direct workflow at :ref:`tutorial-create-direct-rl-env`."
msgstr ""
"We provide a more detailed tutorial for setting up a RL environment using "
"the direct workflow at :ref:`tutorial-create-direct-rl-env`."
