# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2024, The Isaac Lab Project Developers.
# This file is distributed under the same license as the Isaac Lab package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Isaac Lab 1.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-04 11:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:2
msgid "Using a task-space controller"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:6
msgid "In the previous tutorials, we have joint-space controllers to control the robot. However, in many cases, it is more intuitive to control the robot using a task-space controller. For example, if we want to teleoperate the robot, it is easier to specify the desired end-effector pose rather than the desired joint positions."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:11
msgid "In this tutorial, we will learn how to use a task-space controller to control the robot. We will use the :class:`controllers.DifferentialIKController` class to track a desired end-effector pose command."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:17
msgid "The Code"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:19
msgid "The tutorial corresponds to the ``run_diff_ik.py`` script in the ``source/standalone/tutorials/05_controllers`` directory."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:0
msgid "Code for run_diff_ik.py"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:33
msgid "The Code Explained"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:35
msgid "While using any task-space controller, it is important to ensure that the provided quantities are in the correct frames. When parallelizing environment instances, they are all existing in the same unique simulation world frame. However, typically, we want each environment itself to have its own local frame. This is accessible through the :attr:`scene.InteractiveScene.env_origins` attribute."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:41
msgid "In our APIs, we use the following notation for frames:"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:43
msgid "The simulation world frame (denoted as ``w``), which is the frame of the entire simulation."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:44
msgid "The local environment frame (denoted as ``e``), which is the frame of the local environment."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:45
msgid "The robot's base frame (denoted as ``b``), which is the frame of the robot's base link."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:47
msgid "Since the asset instances are not \"aware\" of the local environment frame, they return their states in the simulation world frame. Thus, we need to convert the obtained quantities to the local environment frame. This is done by subtracting the local environment origin from the obtained quantities."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:54
msgid "Creating an IK controller"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:56
msgid "The :class:`~controllers.DifferentialIKController` class computes the desired joint positions for a robot to reach a desired end-effector pose. The included implementation performs the computation in a batched format and uses PyTorch operations. It supports different types of inverse kinematics solvers, including the damped least-squares method and the pseudo-inverse method. These solvers can be specified using the :attr:`~controllers.DifferentialIKControllerCfg.ik_method` argument. Additionally, the controller can handle commands as both relative and absolute poses."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:64
msgid "In this tutorial, we will use the damped least-squares method to compute the desired joint positions. Additionally, since we want to track desired end-effector poses, we will use the absolute pose command mode."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:74
msgid "Obtaining the robot's joint and body indices"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:76
msgid "The IK controller implementation is a computation-only class. Thus, it expects the user to provide the necessary information about the robot. This includes the robot's joint positions, current end-effector pose, and the Jacobian matrix."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:80
msgid "While the attribute :attr:`assets.ArticulationData.joint_pos` provides the joint positions, we only want the joint positions of the robot's arm, and not the gripper. Similarly, while the attribute :attr:`assets.ArticulationData.body_state_w` provides the state of all the robot's bodies, we only want the state of the robot's end-effector. Thus, we need to index into these arrays to obtain the desired quantities."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:86
msgid "For this, the articulation class provides the methods :meth:`~assets.Articulation.find_joints` and :meth:`~assets.Articulation.find_bodies`. These methods take in the names of the joints and bodies and return their corresponding indices."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:90
msgid "While you may directly use these methods to obtain the indices, we recommend using the :attr:`~managers.SceneEntityCfg` class to resolve the indices. This class is used in various places in the APIs to extract certain information from a scene entity. Internally, it calls the above methods to obtain the indices. However, it also performs some additional checks to ensure that the provided names are valid. Thus, it is a safer option to use this class."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:104
msgid "Computing robot command"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:106
msgid "The IK controller separates the operation of setting the desired command and computing the desired joint positions. This is done to allow for the user to run the IK controller at a different frequency than the robot's control frequency."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:110
msgid "The :meth:`~controllers.DifferentialIKController.set_command` method takes in the desired end-effector pose as a single batched array. The pose is specified in the robot's base frame."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:119
msgid "We can then compute the desired joint positions using the :meth:`~controllers.DifferentialIKController.compute` method. The method takes in the current end-effector pose (in base frame), Jacobian, and current joint positions. We read the Jacobian matrix from the robot's data, which uses its value computed from the physics engine."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:131
msgid "The computed joint position targets can then be applied on the robot, as done in the previous tutorials."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:141
msgid "The Code Execution"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:143
msgid "Now that we have gone through the code, let's run the script and see the result:"
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:149
msgid "The script will start a simulation with 128 robots. The robots will be controlled using the IK controller. The current and desired end-effector poses should be displayed using frame markers. When the robot reaches the desired pose, the command should cycle through to the next pose specified in the script."
msgstr ""

#: ../../source/tutorials/05_controllers/run_diff_ik.rst:153
msgid "To stop the simulation, you can either close the window, or press the ``STOP`` button in the UI, or press ``Ctrl+C`` in the terminal."
msgstr ""
